install.packages(c("car", "caTools", "evaluate", "gtools", "markdown", "mvtnorm", "psych", "reshape2", "RWeka", "RWekajars", "scales"))
library(car) # Function Recode
library(psych) # Function Describe
socialPer  <- read.csv("percepcaosocial_df.csv")
aggregate(. ~ X, data = socialPer, FUN = sum)
sum(socialPer$ps032, socialPer$ps033)
rowSums(socialPer[,24:64], na.rm= TRUE)
rowSums(socialPer[,24:64], na.rm= FALSE)
rowSums(socialPer[,24:64])
socialPer  <- read.csv("percepcaosocial_df.csv")
socialPer$scaleSum  <- rowSums(socialPer[,24:64])
socialPer  <- subset(socialPer, subset=socialPer$termo=="Sim" & socialPer$estado=="Finalizadas" & is.na(socialPer$scaleSum))
socialPer  <- read.csv("percepcaosocial_df.csv")
socialPer$scaleSum  <- rowSums(socialPer[,24:64])
socialPer  <- subset(socialPer, subset=socialPer$termo=="Sim" & socialPer$estado=="Finalizadas" & !is.na(socialPer$scaleSum))
kmo = function( data ){
library(MASS)
X <- cor(as.matrix(data))
iX <- ginv(X)
S2 <- diag(diag((iX^-1)))
AIS <- S2%*%iX%*%S2                      # anti-image covariance matrix
IS <- X+AIS-2*S2                         # image covariance matrix
Dai <- sqrt(diag(diag(AIS)))
IR <- ginv(Dai)%*%IS%*%ginv(Dai)         # image correlation matrix
AIR <- ginv(Dai)%*%AIS%*%ginv(Dai)       # anti-image correlation matrix
a <- apply((AIR - diag(diag(AIR)))^2, 2, sum)
AA <- sum(a)
b <- apply((X - diag(nrow(X)))^2, 2, sum)
BB <- sum(b)
MSA <- b/(b+a)                        # indiv. measures of sampling adequacy
AIR <- AIR-diag(nrow(AIR))+diag(MSA)  # Examine the anti-image of the correlation matrix. That is the  negative of the partial correlations, partialling out all other variables.
kmo <- BB/(AA+BB)                     # overall KMO statistic
# Reporting the conclusion
if (kmo >= 0.00 && kmo < 0.50){test <- 'The KMO test yields a degree of common variance unacceptable for FA.'}
else if (kmo >= 0.50 && kmo < 0.60){test <- 'The KMO test yields a degree of common variance miserable.'}
else if (kmo >= 0.60 && kmo < 0.70){test <- 'The KMO test yields a degree of common variance mediocre.'}
else if (kmo >= 0.70 && kmo < 0.80){test <- 'The KMO test yields a degree of common variance middling.' }
else if (kmo >= 0.80 && kmo < 0.90){test <- 'The KMO test yields a degree of common variance meritorious.' }
else { test <- 'The KMO test yields a degree of common variance marvelous.' }
ans <- list( overall = kmo,
report = test,
individual = MSA,
AIS = AIS,
AIR = AIR )
return(ans)
}
kmo(socialPer[,24:64])
scaleKmo  <- kmo(socialPer[,24:64])
scaleKmo$overall
bartlett.test(socialPer[,24:64])
fa.parallel(socialPer[,24:64], fm="pa") # yields 4 components
VSS(socialPer[,24:64], rotate="none") # VSS = 3 factors MAP = 4 components
round(cor(socialPer[,24:64], method="kendal", use="complete.obs"),2) # kendall correlation coef
cor.plot(cor(socialPer[,24:64], method="kendal", use="complete.obs"), numbers= TRUE)
?fa.poly
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin")
sapply(socialPer[,24:64], str)
sapply(socialPer[,24:64], levels)
apply(socialPer[,24:64], levels)
tapply(socialPer[,24:64], levels)
str(socialPer[,24:64])
pca
print.psych(pca, cut = 0.4, sort = FALSE)
print.psych(pca, cut = 0.3, sort = FALSE)
pca$scores
pca$fa
pca$fa$residual
hist(pca$fa$residual)
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin", fm="pc")
print.psych(pca, cut = 0.3, sort = FALSE)
summary(pca)
pca
bfi.dictionary
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin", fm="pa")
print.psych(pca, cut = 0.3, sort = FALSE)
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin", fm="pc")
print.psych(pca, cut = 0.3, sort = FALSE)
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin", fm="pa")
pca <- fa.poly(socialPer[,24:64], nfactors = 4, rotate = "oblimin", fm="pa")
print.psych(pca, cut = 0.3, sort = FALSE)
KMO(socialPer[,24:64])
scaleKmo$overall
plot(pca)
clus  <- iclust(socialPer[,24:64])
